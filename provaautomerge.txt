/*
 * FileName: agreement.js
 * Date: 2018-05-02
 * Authors:
 * - Michele Tagliabue
 * - Daniele Penazzo
 * E-mail: commandlineteam@gmail.com
 *
 * License: Copyright © 2018
 *
 * Description:
 * This is the route that manage proposal, agreement and treatment data
 *
 * Changelog:
 * Date       |  Author           | Description
 * -----------|-------------------|--------------------------------------
 * 2018-05-02 | Michele Talgliabue| First version (getter for proposal)
 * 2018-05-17 | Daniele Penazzo   | Added routes for gathering ids
 * 2018-06-04 | Michele Tagliabue | Add "local" attribute to treatment
 */


/**
 * @module routes/agreement
 * @desc This is the route that manage proposal, agreement and treatment data
 * @requires express
 */

var express = require("express");
var app = express.Router();

var Proposal = require("../models/proposal");
var Treatment = require("../models/treatment");
var User = require("../models/user");
var Local = require("../models/local");
var Event = require("../models/event");
var RevokeAgreement = require("../models/revokeAgreement");
var TuTourSelfMailer = require("../config/mailer");
var mailer = new TuTourSelfMailer();

/**
 * @desc [GET] Route that returns all proposal details, given the id.
 * Proposal id must be part of the URL, like: GET /agreement/ProposalID
 * @name /agreement/
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
//returns the proposal, given the id
app.get("/:id",function(req,res) {
    var proposalId = req.params.id;
    Proposal.findById(proposalId, function (error,proposal) {
        if(error) {
            res.send({
                status: "error",
                message: error
            });
            return;
        }
        if(!proposal) {
            res.send({
                status: "error",
                message: "No proposal found"
            });
            return;
        }
        //If user is not the recipient or the emitter of the proposal and is
        //not an administrator, he does not have the rights to view it
        if(!req.user || (String(proposal.from) !== String(req.user._id) &&
            String(proposal.to) !== String(req.user.id) &&
            !req.user.isAdmin())) {

            res.send({
                status: "error",
                message: "Forbidden"
            });

            return;
        }

        proposal
            .populate("place revokeAgreement", function (err,prop) {
                if(err || !prop) {
                    res.send({
                        status: "error",
                        message: err
                    });
                    return;
                }
                //return the proposal
                res.send({
                    status: "found",
                    proposal: prop
                });
            });
    });
});

/**
 * @desc [POST] Route insert a new proposal in database.
 * Proposal data must passed as POST parameters, like:
 * {
 *     from: "",
 *     to: "",
 *     treatment: "",
 *     place: "",
 *     comment: "",
 *     duration: "",
 *     amount: "",
 *     eventDate: ""
 * }
 * @name /agreement/proposal
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
//proposal insert
app.post("/proposal",function(req,res) {

    if(!req.user ||
        (!req.user.isAdmin() &&
            String(req.user._id) !== String(req.body.from)) &&
            String(req.user._id) !== String(req.body.to)) {
        res.send({
            status: "error",
            message: "Forbidden 1"
        });
        return;
    }
ciao culo
prova di tutto sto modificando un sacco
boia can
        User.findById(req.body.from, function(e,u) {
            if(e || !u) {
                res.send({
                    status: "error",
                    message: e ? e : "Invalid parameters2"
                });
                return;
            }
            Local.findById(req.body.place, function(er,local) {
                if(er || !local) {
                    res.send({
                        status: "error",
                        message: er ? er : "Invalid parameters3"
                    });
                    return;
                }
                if(String(local.manager_id) !== String(req.body.from) &&
                   String(local.manager_id) !== String(req.body.to)) {
                    res.send({
                        status: "error",
                        message: "Invalid place"
                    });
                    return;
                }
                var treatmentID = req.body.treatment;
                if(treatmentID == null || !treatmentID) {
                    var treatment = new Treatment();
                    treatment.setUsers([req.body.from,req.body.to]);
                    treatment.setStartDate(new Date());
                    treatment.setLocal(local._id);
                    treatment.save(function(err) {
                        if(err) {
                            res.send({
                                status: "error",
                                message: "Error creating treatment"
                            });
                            return;
                        }
                        treatmentID = treatment._id;
                        insertProposal(treatment,req,res);
                    });
                }
                else {
                    Treatment.findById(treatmentID, function (error, treatment){
                        if (error) {
                            res.send({
                                status: "error",
                                message: error
                            });
                            return;
                        }
                        if (!treatment) {
                            res.send({
                                status: "error",
                                message: "treatment not found"
                            });
                            return;
                        }
                        insertProposal(treatment, req, res);
                    });
                }
            });

        });
    });
});

/**
 * @function insertProposal
 * @memberof module:routes/agreement
 * @desc auxiliary function of proposal creation
 * @param {Treatment} treatment - id of related treatment
 * @param {Request} req - express.js request object
 * @param {Response} res - express.js response object
 * @returns {void}
 */
function insertProposal(treatment,req,res) {
    try {
        var proposal = new Proposal();

        proposal.setTreatment(treatment._id);
        proposal.setFrom(req.body.from);
        proposal.setTo(req.body.to);
        proposal.setPlace(req.body.place);
        proposal.setSendDate(new Date());
        proposal.setComments(req.body.comment);

        if(!proposal.setDuration(req.body.duration)) {
            res.send({
                status: "error",
                message: "Invalid parameters (duration not valid)"
            });
            return;
        }

        //proposal.treatment = treatment._id;
        //proposal.from = req.from;
        //proposal.to = req.to;
        //proposal.sentOn = new Date();

        if (!proposal.setAmount(req.body.amount)) {
            res.send({
                status: "error",
                message: "Invalid parameters (amount not valid)"
            });
            return;
        }


        proposal.setEventDate(new Date(req.body.eventDate));
        proposal.save(function(err) {

            if(err) {
                res.send({
                    status: "error",
                    message: "Error saving proposal"
                });
                return;
            }
            proposal.populate("place revokeAgreement",function(error) {
                if(error) {
                    res.send({
                        status: "error",
                        message: error
                    });
                    return;
                }
                const socket1 =
                    req.app.locals.userSocketArray.peek(proposal.from);
                const socket2 =
                    req.app.locals.userSocketArray.peek(proposal.to);
                User.findById(proposal.from, (err, item) => {
                    for (let i = 0, len = socket1.length; i < len; i++) {
                        req.app.locals.io.to(socket1[i].id).emit("newProposal");
                    }
                    for (let i = 0, len = socket2.length; i < len; i++) {
                        req.app.locals.io.to(socket2[i].id).emit("newProposal");
                        req.app.locals.notificationManager
                            .notifyUser(proposal.to,{
                                type: "newProposal",
                                sender: item.name + " " + item.surname
                            });
                    }

                    User.findById(proposal.to, (err,dest) => {

                        mailer.sendProposalMailFrom(item);
                        mailer.sendProposalMailTo(dest);

                        res.send({
                            status: "success",
                            proposal: proposal
                        });
                    });

                });

            });
        });
    }
    catch(e) {
        res.send({
            status: "error",
            message: "Exception in proposal creation " + e
        });
    }
}

/**
 * @desc [POST] Route that, given an array of two users and a place, should
 * return the treatments between the two, regarding the specific place.
 * The array of user must be passed as POST parameter "userArray", while the
 * place id must be passed as POST parameter "local"
 * @name /agreement/treatment/users
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
//given an array of two users, should return the treatments between the two
app.post("/treatment/users", function(req, res){
    let users = req.body.userArray;
    let local = req.body.local;
    Treatment.find(
        {users: {$all: users}, local: local}).exec(
        (err, treatments) =>{
            if (err){
                res.send({"status": "failure",
                          "message": "Error while finding treatments:" + err});
                return;
            }

            res.send({"status": "success",
                      "message": "Treatments found",
                      "treatments": treatments});
        });

});

/**
 * @desc [GET] Route that gets treatment by ID and also all related proposals.
 * The treatment ID must be passed as part of the URL, like:
 * GET /agreement/treatment/treatmentID
 * @name /agreement/treatment
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
//Get treatment by ID and also all related proposals
app.get("/treatment/:id",function (req,res) {
    var treatmentId = req.params.id;
    Treatment.findById(treatmentId,function(error, treatment) {
        if(error) {
            res.send({
                status: "error",
                message: error
            });
            return;
        }

        if(!treatment) {
            res.send({
                status: "error",
                message: "No proposal found"
            });
            return;
        }

        if(!req.user || (String(treatment.users[0]) !== String(req.user._id) &&
            String(treatment.users[1]) !== String(req.user._id) &&
            !req.user.isAdmin())) {

            res.send({
                status: "error",
                message: "Forbidden 2"
            });
            return;
        }

        var proposals = [];
        Proposal.find({treatment: treatment._id})
            .populate("place revokeAgreement")
            .exec(function (errT,arrayT) {
                if(errT) {
                    res.send({
                        status: "error",
                        message: errT
                    });
                    return;
                }
                if(arrayT)
                    proposals = arrayT;

                res.send({
                    status: "success",
                    proposals: proposals
                });
            });
    });
});

/**
 * @desc [POST] Route that confirm a proposal, which became an agreement.
 * Id of proposal to confirm must be passed as POST parameter "proposal"
 * @name /agreement/confirm
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
app.post("/confirm",(req,res) => {

    let proposalId = req.body.proposal;

    Proposal.findById(proposalId,(error,proposal) => {
        if(error || !proposal) {
            res.send({
                "status": "error",
                "message": error ? error : "No proposal found"
            });
            return;
        }
        let proposalSchema = new Proposal(proposal);

        if(!req.user._id.equals(proposal.getTo())) {
            res.send({
                "status": "error",
                "message": "Forbidden"
            });
            return;
        }

        if(proposalSchema.getConfirmationDate() != null) {
            res.send({
                "status": "error",
                "message": "Proposal already confirmed"
            });
            return;
        }

        if(proposalSchema.revokeAgreement != null) {
            res.send({
                "status": "error",
                "message": "Proposal has been revoked or is been revoking"
            });
            return;
        }

        const confirmationDate = new Date();
        proposalSchema.setConfirmationDate(confirmationDate);

        proposalSchema.save((e) => {
            if(e) {
                res.send({
                    "status": "error",
                    "message": "Error confirming proposal: " + e
                });
                return;
            }

            Treatment.findById(proposalSchema.getTreatment(),(er,tr) => {
                if(er) {
                    res.send({
                        "status": "error",
                        "message": "Error confirming proposal: " + e
                    });
                    return;
                }
                let treatment = new Treatment(tr);
                treatment.setFinishDate(confirmationDate);
                treatment.save((errore) => {
                    if(errore) {
                        res.send({
                            "status": "error",
                            "message": "Error confirming treatment"
                        });
                        return;
                    }
                    res.send({
                        "status": "success",
                        "message": "proposal confirmed successfully"
                    });

                    const socket =
                        req.app.locals.userSocketArray
                            .peek(proposalSchema.getFrom());

                    for (let i = 0, len = socket.length; i < len; i++) {
                        req.app.locals.io.to(socket[i].id)
                            .emit("proposalConfirmed");
                    }

                    req.app.locals.notificationManager
                        .notifyUser(proposalSchema.getFrom(),{
                            type: "proposalConfirmed",
                            sender: req.user.name + " "
                                + req.user.surname
                        });

                });
            });


        });
    });
});

/**
 * @desc [POST] Route that revokes a proposal or an agreement.
 * Id of the proposal (confirmed or not) to revoke must be passed as POST
 * parameter "proposal"
 * @name /agreement/revoke
 * @function
 * @memberof module:routes/agreement
 * @inner
 * @param {string} path - Express path
 * @param {callback} middleware - Express middleware.
 */
app.post("/revoke",(req,res) => {
    if(req.user == null || !req.user) {
        res.send({
            "status": "error",
            "message": "Forbidden (unlogged)"
        });
        return;
    }

    let proposalId = req.body.proposal;

    Proposal.findById(proposalId,(error,p) => {
        if(error || !p) {
            res.send({
                "status": "error",
                "message": error ? error : "No proposal found"
            });
            return;
        }

        let proposal = new Proposal(p);


        if(proposal.isConfirmed()) {
            RevokeAgreement.findById(proposal.revokeAgreement,(error,rA) => {
                if(error) {
                    res.send({
                        "status": "error",
                        "message": "Error in mongoose query"
                    });
                    return;
                }
                if(!rA) {
                    rA = new RevokeAgreement();
                    rA.setSender(req.user._id);
                    rA.setReceiver(
                        proposal.from.equals(req.user._id) ?
                            proposal.to : proposal.from
                    );
                    rA.setReason("Default reason");

                    rA.save((error,reA) => {
                        if(error || !reA) {
                            res.send({
                                "status": "error",
                                "message": "Error saving revoke request"
                            });
                            return;
                        }
                        proposal.revokeAgreement = reA._id;

                        proposal.save((e) => {
                            if(e) {
                                res.send({
                                    "status": "error",
                                    "message": "Error saving revoke request" +
                                        " in proposal"
                                });
                                return;
                            }
                            res.send({
                                status: "needsCompletion",
                                message: "Proposal revoke request saved" +
                                    " succesfully. Now you have to wait for" +
                                    " the confirmation of the other user"
                            });

                            const socket =
                                req.app.locals.userSocketArray
                                    .peek(rA.getReceiver());

                            for (let i = 0, len = socket.length; i < len; i++) {
                                req.app.locals.io.to(socket[i].id)
                                    .emit("agreementRevoke");
                            }

                            req.app.locals.notificationManager
                                .notifyUser(rA.getReceiver(),{
                                    type: "agreementRevoke",
                                    sender: req.user.name + " "
                                        + req.user.surname
                                });
                        });
                    });
                }

                else {
                    if(!rA.getReceiver().equals(req.user._id)) {
                        res.send({
                            status: "error",
                            message: "Forbidden. You cannot confirm this" +
                                " agreement revoke!"
                        });
                        return;
                    }
                    rA.setAck(new Date());
                    rA.save((error) => {
                        if(error) {
                            res.send({
                                "status": "error",
                                "message": "Error saving agreement revoke"
                            });
                            return;
                        }
                        res.send({
                            "status": "success",
                            "message": "Agreement has been revoked"
                        });
                        const socket =
                            req.app.locals.userSocketArray.peek(rA.getSender());

                        for (let i = 0, len = socket.length; i < len; i++) {
                            req.app.locals.io.to(socket[i].id)
                                .emit("agreementRevokeConfirmation");
                        }

                        User.findById(rA.getSender(),(q,w) => {
                            if(!q && w)
                                req.app.locals.notificationManager
                                    .notifyUser(rA.getSender(),{
                                        type: "agreementRevokeConfirmation",
                                        sender: w.name + " "
                                            + w.surname
                                    });
                        });

                        //Don't care about callback here
                        Event.remove({acceptedProposalId: proposalId},()=> {
                            //Need callback otherwise remove will never be
                            //triggered
                        });
                    });
                }
            });
            return;
        }

        let treatmentId = proposal.getTreatment();

        if(!proposal.getFrom().equals(req.user._id)) {
            res.send({
                "status": "error",
                "message": "Forbidden"
            });
            return;
        }
        proposal.remove((error) => {
            if(error) {
                res.send({
                    "status": "error",
                    "message": "Error revoking proposal"
                });
                return;
            }

            Proposal.find({treatment: treatmentId},(a,b) => {
                if(a) {
                    res.send({
                        "status": "error",
                        "message": "Proposal find error"
                    });
                    return;
                }

                if(b.length < 1) {
                    //Empty treatment. Remove to avoid database garbage
                    Treatment.findByIdAndRemove(treatmentId,(errore) => {
                        if(errore) {
                            res.send({
                                "status": "error",
                                "message": "Error removing treatment"
                            });
                            return;
                        }
                        sendSuccessMessage(res);
                    });
                }
                else {
                    //Treatment not empty. Cannot remove it
                    sendSuccessMessage(res);
                }
            });

        });
    });
});

/**
 * @function sendSuccessMessage
 * @memberof module:routes/agreement
 * @desc auxiliary function of agreement (propsal) revoke
 * @param {Response} res - express.js response object
 * @returns {void}
 */
function sendSuccessMessage(res) {
    res.send({
        "status": "success",
        "message": "Proposal has been revoked successfully"
    });
}

module.exports = app;
